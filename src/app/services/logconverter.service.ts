import { Injectable } from '@angular/core';

export interface Log {
  Datum: Date;
  Uhrzeit: string;
  Loglevel: string;
  Nachricht: string;
  Quelle: string;
}

const logs: Log[] = [];

const THEMA_MAPPING: { [key: string]: string[] } = {
  Wlan: ['WlanManager', 'WlanStatus'],
  Bluetooth: ['Bluetooth'],
  Engine: ['Engine'],
  Drucken: ['print', 'Printer'],
  Einsatzerstellung: ['Generating'],
  Einsatzabschluss: ['removing silent record!', 'NIDA ID in Finish'],
  Nida_Start: ['NIDA started'],
  Benutzer_Reset: ['Neustart durch den Benutzer'],
  Manuell_gelÃ¶scht: ['Engine.record_do_action: removing record!'],
};

@Injectable({
  providedIn: 'root',
})
export class LogConverterService {
  getLogs(): Log[] {
    return logs;
  }

  parseLogs(logContent: string, fileName: string): Log[] {
    const logLines = logContent.split('\n').map((line) => line.trim());
    const parsedLogs: Log[] = [];

    const isPreferencesFormat = logLines[0]
      ?.trimStart()
      .startsWith('# preferences generated by');

    if (isPreferencesFormat) {
      for (const line of logLines) {
        if (line.includes('=')) {
          const [key, value] = line.split('=');
          parsedLogs.push({
            Datum: new Date(),
            Uhrzeit: '',
            Loglevel: '',
            Nachricht: `${key.trim()} = ${value.trim()}`,
            Quelle: '',
          });
        }
      }
      return parsedLogs;
    }

    const logRegex =
      /(\d{4}[-.]\d{2}[-.]\d{2}|\d{2}[-.]\d{2}[-.]\d{4})[ \t]+(\d{2}:\d{2}:\d{2})(?:\.\d{1,4})?[ \t]*(\[?(Info|Warn|Error|Fatal|INF|WRN|ERR|FTL)?\]?)?:?[ \t]*(.*)/;

    const serilogRegex =
      /^\[(\d{4}\.\d{2}\.\d{2}) (\d{2}:\d{2}:\d{2})\.\d{3} ([A-Z]+)\s+([\w\d.\s]+)\s*\]? (.*)$/;

    let currentLog: Log | null = null;

    logLines.forEach((line) => {
      if (fileName === 'preferences.txt') {
        line = line.replace(/ /g, '\n');
      }
      let match = serilogRegex.exec(line);
      const isSerilog = !!match;

      if (!isSerilog) {
        match = logRegex.exec(line);
      }

      if (match) {
        if (currentLog) {
          parsedLogs.push(currentLog);
        }

        const [date, time, logLevel, rawSource, message] = match;
        const cleanedMessage = message?.trim() || '';
        const cleanedLogLevel = logLevel?.replace(/[[\]]/g, '') || '';
        const source = isSerilog
          ? rawSource
          : this.determineSource(cleanedLogLevel, cleanedMessage);

        currentLog = {
          Datum: this.formatDateAsDateObj(date, isSerilog),
          Uhrzeit: time.split('.')[0],
          Loglevel: cleanedLogLevel,
          Nachricht: cleanedMessage,
          Quelle: source,
        };
      } else if (currentLog) {
        currentLog.Nachricht += ' ' + line;
      } else {
        const cleanedMessage = line.trim();
        const log: Log = {
          Datum: new Date(),
          Uhrzeit: '',
          Loglevel: '',
          Nachricht: cleanedMessage,
          Quelle: '',
        };
        parsedLogs.push(log);
      }
    });

    if (currentLog) {
      parsedLogs.push(currentLog);
    }

    return parsedLogs;
  }

  formatDate(date: string): string {
    if (date.includes('-')) {
      return date.replace(/-/g, '.');
    }
    const parts = date.split('.');
    if (parts.length === 3) {
      return `${parts[2]}.${parts[1]}.${parts[0]}`;
    }

    return date;
  }

  determineSource(logLevel: string, message: string): string {
    for (const [source, keywords] of Object.entries(THEMA_MAPPING)) {
      if (keywords.some((keyword) => message.includes(keyword))) {
        return source;
      }
    }
    return '';
  }

  formatDateAsDateObj(date: string, isSerilog = false): Date {
    let day, month, year;
    if (isSerilog) {
      const [yyyy, MM, dd] = date.split('.');
      return new Date(parseInt(yyyy), parseInt(MM) - 1, parseInt(dd));
    } else {
      if (date.includes('-')) {
        [year, month, day] = date.split('-');
      } else {
        [day, month, year] = date.split('.');
      }
      return new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
    }
  }
}
